### 날짜: 2023-01-10 00:57

### 주제: 파티션, 디렉터리 구조, LVM과 RAID
---
### 메모: 
##### 파일 시스템 
- 컴퓨터에서 데이터를 기록하기 위해서는 미리 하드디스크의 데이터를 읽고, 쓰고, 검색을 위한 준비를 해야 하는데 **파일 시스템은 그 준비의 규칙을 정리한 것으로 파일에 이름을 붙이고 저장이나 검색을 위하여 파일을 어디에 위치시킬 것인지를 나타내는 모든 조직체계이다.**
- 계층 구조 파일 시스템을 가지고 있다. 
- 파일 시스템의 디렉터리는 커널에 의해서 관리된다. 
- 파일 시스템에서 확장자의 의미는 없으며, 확장자를 부여하지 않아도 된다. 
- 일반적으로 '/home'은 사용자 계정을 위한 디렉터리로 사용된다. 
- 파일 시스템 기능
	- 파일에 대한 다양한 종류의 접근제어 방법을 제공
	- 파일의 생성, 수정, 삭제 등을 관리
	- 파일의 무결성 유지와 보안 유지 기능을 제공
	- **데이터의 백업 및 복구기능을 제공**
	- 데이터의 효율적 저장과 관리를 위한 방법을 제공
- 파일 시스템 종류

| 종류       | 유형                                                      |
| ---------- | --------------------------------------------------------- |
| 리눅스     | ext, ext2, ext3, ext4                                     |
| 저널링     | JFS, XFS, ReiserFS                                        |
| 네트워크   | SMB, CIFS, NFS                                            |
| 윈도       | FAT, FAT32, VFAT, NTFS                                    |
| CD-ROM     | iso9660                                                   |
| 유닉스     | HPFS, SysV                                                |
| 클러스터링 | RedHat GFS, IBM GPFS, IBM SanFS, Compaq CFS, Oracle OCFS2 |
- **ext의 특징** 
	- 파일명은 대/소문자를 구분한다.
	- 일반 파일, 장치 파일, 디렉터리를 모두 하나의 파일 개념으로 취급한다. 
	- 파일명 내의 공백이나 필드 분리자 등을 포함할 수 있다. 
	- ext2, ext3, ext4, zfs는 255바이트 크기로 파일 이름을 제한한다. 
##### 파티션
- **하나의 물리적인 디스크를 여러 개의 논리적인 디스크로 분할하는 것을 의미한다.** 
- 파티션 상태를 확인하는 파일 : **/proc/partitions**
- 파티션은 실린더를 기준으로 나뉘어 진다. 
###### 종류
- **Primary Partition**
	- 하나의 하드디스크에 기본 파티션과 확장 파티션 모두 4개의 파티션까지 분할 가능
	- 4개 이상의 파티션이 필요한 경우 확장 파티션 내에 논리 파티션은 만듦
	- *주 파티션 3개 사용 후 확장 파티션의 선언이 가능함*
	- 주 파티션은 4개까지 사용 가능하다.
- **Extended Partition**
	- 하드디스크를 여러 개의 파티션으로 나누고자 할 때 만드는 파티션
	- *논리 파티션을 만들 수 있게 하는 공간으로 디스크당 하나만 만들 수 있음*
- **Logical Partition**
	- *4개 이상의 파티션을 사용하게 되는 경우 확장 파티션 내에 논리 파티션 생성*
	- *하나의 하드디스크에서 논리 파티션의 수는 최대 12개까지 생성 가능*
- **Swap Partition**
	- *하드디스크 일부를 주기억장치처럼 사용하는 가상기억장치*
	- 리눅스 설치 시 반드시 필요한 영역
	- 기본 파티션 또는 논리 파티션에 생성
	- 메모리가 완전히 가득 차면 추가적으로 실행되는 프로그램은 메모리가 아닌 스왑 파티션에서 실행된다.
	- **스왑 영역의 크기는 일반적으로 주기억장치의 2배로 설정** 
###### 장점
- 파티션마다 독립적인 파일 시스템이 운영되기 때문에 파일 점검 시간이 줄어서 **부팅 시간을 단축시킨다.**
- 특정 파티션의 파일 시스템이 손상되어도 다른 파티션에 영향을 주지 않기 때문에 **안정성이 높아진다.**
- 필요한 파티션만 포캣이 가능하기 때문에 **백업과 업그레이드가 편하다.**
###### 파티션 분할
- 하나의 하드디스크 기억 공간을 별도의 데이터 영역으로 분할한다.
- fdisk 명령어로 디스크 파티션을 생성, 수정, 삭제 등을 관리할 수 있다.
- <code>[root@ localhost ~]# fdisk [옵션][장치명]</code>
	- - a ) 부팅 가능한 플래그로 지정
	- - l ) 알려진 파티션 유형 목록 출력 
	- - m ) 이 목록 출력
	- - n ) 새로운 파티션 생성
	- - t ) 파티션 유형 변경
	- - w ) 파티션 정보를 디스크 테이블에 기록 
	- - p ) 파티션 정보 확인
	- - q ) 작업 종료 후 빠져나감
###### 디스크와 장치명
- **플로피 디스크**
	- 첫 번째 플로피 디스크 <code>/dev/fd0</code> 
	- 두 번째 플로피 디스크 <code>/dev/fd1</code>
- I**DE 유형 디스크** 
	- Primary Master <code>/dev/hda</code>
	- Primary Slave <code>/dev/hdb</code>
	- Secondary Master <code>/dev/hdc</code>
	- Secondary Slave <code>/dev/hdd</code>
- **SCSI 유형 디스크** 
	- 첫 번째 드라이브 <code>/dev/sda</code>
	- 두 번째 드라이브 <code>/dev/sdb</code>
- **CD-ROM**
	- SCSI CD-ROM <code>/dev/scd0 or /dev/sr0</code>
- ex) <code>/dev/sda2</code>
	- *SCSI 유형 하드 디스크*
	- *첫 번째 물리적인 하드 디스크*
	- *두 번째 파티션*
##### 디렉터리
- 최상위 디렉터리(/) 아래로 계층적인 트리 구조로 이루어져 있다. 
- <code>/</code>
	- 최상위 디렉터리로 루트 디렉터리라고 함 
- <code>/bin</code>
	- 'System Binary'의 약어로 이진 파일이며, 리눅스에서 *기본 명령어*가 저장된 디렉터리
- <code>/usr</code>
	- *시스템에 사용되는 각종 프로그램이 설치*되는 디렉터리
- <code>/etc</code>
	- *리눅스 시스템의 각종 환경설정 파일과 디렉터리*가 저장된 디렉터리 
- <code>/sbin</code>
	- *시스템 관리를 위한 명령어*가 저장된 디렉터리
- <code>/lib</code>
	- *프로그램의 각종 라이브러리 파일이 저장된 디렉터리로 유틸리티, 패키지 등의 파일 포함*
- <code>/var</code>
	- 시스템에서 사용되는 *동적인 파일을 저장*하는 디렉터리
	- 각종 시스템 로그파일, 사용자 로그인에 대한 로그 기록
	- 메일서버를 운영한다면 사용자에게 전송된 메일을 임시로 저장하는 디렉터리
- <code>/tmp</code>
	- 각 장치에 필요한 'socket' 및 'log' 파일들이 위치하고, *시스템에 필요한 임시 파일들을 만들고 삭제*하는 디렉터리이다. 
	- 임시 디렉터리로 스티키 비트가 설정되어 있음
		- 유닉스 운영체제는 기본적으로 파일의 소유자가 아니면 해당 디렉토리 내의 파일을 지우거나 수정하지 못하도록 기본적인 umask를 설정한다. 하지만 딱~두군데 모든 사용자 계정이 파일을 만들고 수정, 삭제할 수 있는 디렉토리가 있다. 바로 /tmp와 /var/tmp다. 이 두개의 디렉토리는 퍼미션이 기본적으로 777로 설정되어 있어 누구나 임의의 파일을 생성하고 수정하고 삭제할 수 있다. 말 그대로 모든 사용자 계정이 사용하는 공용 디렉토리다.
		- 그러다 보니... 이 두개의 디렉토리에 퍼미션이 777 퍼미션을 갖는 파일들과 디렉토리들이 생겨나게 되는데...문제는 이 파일들이 꼭 필요한 파일인지 알 수 없고 현재 사용중인지 아닌지를 판단하기 어렵다 보니 파일 퍼미션이 777인 파일들을 아무나 다른 소유자의 파일들을 지워버리는 문제가 생겨난다. 하지만 그 파일들이 현재 사용중인 파일이라면 서비스에 장애가 발생하게 되는 것이다.
		- 그래서 등장한 것이 sticky bit 이다.
		- sticky bit가 설정된 디렉토리 내에서는 
		1. 퍼미션이 777인 파일에 대해서 파일의 소유자만이 삭제를 할 수 있다. (수정이나 실행, 읽기는 모두 허용된다.)
		2. sticky bit가 설정된 디렉토리 자체도 소유자만이 삭제할 수 있다.
		3. root는 다할 수 있다.
		- 즉... 파일을 만든 계정과 root에서만 삭제할 수 있다는 뜻이다. 비록 파일의 퍼미션이 777이더라도 말이다.
- <code>/root</code>
	- 시스템 관리자(root)의 홈 디렉터리 
- <code>/proc</code>
	- *시스템의 각종 프로세서, 프로그램 정보 그리고 하드웨어 정보가 저장된 디렉터리*
	- *가상 파일 시스템으로 하드디스크에 물리적인 용량을 가지지 않는 디렉터리*
	- 시스템 관리를 목적으로 메모리상에 만들어 놓은 가상 디렉터리로, 디렉터리 내의 파일들은 현재 시스템 설정을 보여준다. 
- <code>/dev</code>
	- 시스템의 각종 장치에 접근하기 위한 장치 드라이버가 저장된 디렉터리
	- 시스템 중에서 *주변 장치 파일이 저장*되어 있는 디렉터리
- <code>/home</code>
	- 일반 사용자의 홈 디렉터리
- <code>/opt</code>
	- *추가된 응용 프로그램 패키지*가 설치되는 디렉터리이다. 
##### LVM(Logical Volume Manager)
- **논리 볼륨 관리자라는 의미로 여러 개의 물리적인 하드디스크를 논리적인 디스크로 할당하여 유연하게 관리할 수 있도록 도와준다.**
- 여러 개의 물리적인 하드디스크를 하나의 대용량 파일 시스템으로 만든다. 
- **서버 운영 시 대용량 저장 공간이 필요할 때 주로 사용한다.**
- **물리적 볼륨** PV
	- 각각의 파티션을 'LVM'으로 사용하기 위해 형식을 변환시킨 것(/dev/hda1, /dev/hda2 등)
- **볼륨 그룹** VG
	- 'PV'로 되어 있는 파티션을 하나의 물리적인 그룹으로 만듦
	- '/dev/sda1'을 하나의 그룹으로 만들 수 있고, '/dev/sda1'과 '/dev/sda2' 파티션 두 개를 하나의 그룹으로 만들 수 있음
- **논리적 그룹** LV
	- 사용자가 다루게 되는 부분 
	- 마운트 포인터로 사용할 실질적인 파티션
	- 크기를 확장 및 축소 시킬 수 있음
##### RAID(Redundant Array of Independent Disks)
- **여러 개의 물리적인 하드디스크를 하나의 논리적인 디스크로 인식하게 만드는 기술이다.**
- 중요한 데이터를 가지고 있는 서버에 주로 사용되며 여러 개의 하드디스크에 동일한 데이터를 다른 위치에 중복해서 저장하는 기술이다. 
- 하드웨어 RAID
	- 하드웨어 제조업체에서 여러 개의 하드디스크로 만들어 공급
	- 안정적이지만, 고가 
- 소프트웨어 RAID
	- 주로 운영체제 안에서 구현되며, 하드웨어 RAID 대안 
	- 하드웨어 구성에 비해 성능향상 적고, 안정성이 떨어짐
###### RAID 0
- 빠른 데이터의 입출력을 위해 스트라이핑(Striping)을 사용한다. 
- *하나의 디스크에 오류가 발생하면 모든 데이터를 잃을 수 있다. *
	- 스트라이핑: 성능 향상을 위해 데이터를 1개 이상의 디스크 드라이브에 저장하여 드라이브를 병렬로 사용할 수 있는 기술이다. 논리적으로 연속된 데이터들이 여러 개의 물리적인 디스크 드라이브에 나누어 저장하는 기술이다. 
###### RAID 1 
- 두 개 이상의 디스크를 미러링(Mirroring)을 통해 하나의 디스크처럼 사용한다. 
- 완전히 동일한 데이터를 복제하기 때문에 사용할 수 있는 용량이 절반밖에 되지 않는다.
###### RAID 0+1
- RAID 0과 RAID 1을 결합하는 방식이다. 
- 최소 4개 이상의 디스크에서 먼저 2개씩 RAID 0으로 묶고 이것을 다시 RAID 1으로 결합하는 방식이다. 
###### RAID 2
- *오류 정정을 위해 해밍 코드(Hamming Code)를 사용하는 방식으로 비트 단위에 해밍 코드를 적용한다. *
- 최근 디스크 드라이브에는 기본적으로 오류 검출 기능이 있으므로 거의 사용하지 않는다.
	- 해밍 코드: 데이터의 오류를 검출하고 수정하는 오류 수정 코드이다. 
###### RAID 3/4
- *하나의 디스크를 패리티(Parity) 정보를 위해 사용하고, 나머지 디스크에 데이터를 균등하게 분산 저장하는 방식이다. *
- 읽기 성능은 'RAID 0'과 비슷하나, 쓰기는 패리티 처리로 인해 일부 성능이 저하된다. 
- 하나의 디스크에 오류가 발생하면 패리티 디스크를 통해 복구할 수 있다. 
- RAID 4, RAID 3은 같으나, *블록 단위로 분산 저장하는 차이가 있으며,* 모든 블록이 각 디스크에 균등하게 저장되지 않는다.
- 병목 현상이 발생하면 성능 저하가 발생할 수 있다. 
	- Parity: 정보의 전달 과정에서 오류가 생겼는지 검사하기 위해 추가되는 비트이다.
		- *데이터를 송수신하는 과정에서 각 비트를 단위시간 당 하나씩 보내게 되어있는데, 이 때 알수 없는 이유로 비트의 값이 틀어져 1이 0으로, 0이 1로 바뀌었을 때 이를 확인 할 수 있게 한다. (1의 갯수가 홀이냐 짝이냐 )*
###### RAID 5 
- 3개 이상의 디스클 사용하여 하나의 디스크처럼 사용하고, 각각의 디스크에 패리티 정보를 가지고 있는 방식이다. 
- *하나의 디스크에 오류가 발생해도 다른 두 개의 디스크를 통해 복구할 수 있다. *
- 패리티 디스크를 별도로 사용하지 않으므로 병목 현사이 발생하지 않는다. 
###### RAID 6
- 하나의 패리티를 두 개의 디스크에 분산 저장하는 방식이다. 
- 패리티를 이중으로 저장하기 때문에 두 개의 디스크에 오류가 발생해도 복구할 수 있다. 
- 쓰기 속도를 패리티를 10번 쓰기 때문에 느려질 수 있지만, 안정성은 높아진다. 
##### 기타
- **Disk Druid**
	- GUI 환경으로 사용자가 좀 더 쉽게 파티션을 분할 할 수 있도록 지원하는 유틸리티이다.
- 라이브러리
	- 다른 프로그램들과 링크되기 위하여 존재하는 하나 이상의 서브루틴이나 함수들의 집합을 말하는데, 보통 컴파일된 형태인 목적코드 형태로 존재한다. 
- 파이프 
	- **한 프로그램 프로세스에서 다른 프로세스로 정보를 전달하는 기술이다.** 리눅스에서는 2개 이상의 명령어를 연결할 때 사용한다. 
- 리다이렉션
	- 표준 입력이나 표준 출력을 키보드나 화면으로 하는 것이 아니라, 방향을 바꿔서 파일로 입력을 받거나 파일로 출력하고자 할 때 사용한다. 

### 출처(참고문헌) 
- 한 권으로 끝내기 리눅스 마스터 2급
- https://blogger.pe.kr/384

### 연결문서 
- [[2. 리눅스 설치 - 1 리눅스 설치 및 유형]]
- [[2. 리눅스 설치 - 2 리눅스 부트]]

### Tag
- #CS/Linux 
- #LinuxMaster 