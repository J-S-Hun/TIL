### 날짜: 2023-05-06 17:33

### 주제: 비동기 작업을 위한 커스텀 Operation
---
### 메모: 
#### Asynchronous operations 
- 동기적인 작업들은 Operation 클래스와 매우 잘 작동한다. 
- 동기적인 Operation 작업은, 작업이 `isReady` 상태로 전환되면 시스템은 사용 가능한 스레드를 찾기 시작한다. 스케줄라가 작업을 실행할 스레드를 찾으면 작업은 `isExecuting` 상태로 전환된다. 그 시점에서 코드가 실행되고 완료되면 상태는 `isFinished`가 된다. 
- 하지만, Operation 안에 작업이 비동기로 작동하게 될 때 문제가 발생하게 된다. 
- Operation이 작동 후 Operation 내부의 비동기 작업이 시작되고 Operation이 종료된다. 이 시점에서 **비동기 메서드가 아직 완료되지 않았을 가능성이 있기 때문에 작업의 상태를 `isFinished`로 전환을 수동으로 해줘야 한다.** 
- 모든 상태 속성값은 read-only여서 직접적으로 수정하는 것은 불가능하지만, 그래도 어느정도 간단하게 조정할 수 있다. 한 번 비동기 operation을 작성하면 이를 subclass화 하여 계속해서 사용할 수 있다. 
##### AsyncOperation 
- Apple은 `Operation` 클래스를 통해 개발자에게 동기 및 비동기 작업에 대한 기본 틀을 제공하며, 이 클래스는 매우 일반적이고 다양한 사용 사례에 맞게 확장 및 조정이 가능하도록 설계되어져있다. 이렇게 설계하는 것이 개발자에게 더 많은 유연성과 커스터마이징 옵션을 제공할 수 있기 때문이다.
- `AsyncOperation`은 비동기 작업에 대한 상속 클래스로 구현될 수 있으며, 이를 구현하는 것은 상대적으로 간단한 작업이다. 이러한 구현을 제공하지 않음으로써 Apple은 개발자에게 프로젝트 요구 사항에 따라 비동기 작업에 대한 더 세밀한 제어와 필요한 추가 기능을 구현할 수 있는 기회를 제공한다.
- 또한 `Operation` 클래스를 직접 사용하면서 동기 또는 비동기 작업을 구현할 수 있기 때문에, Apple은 필요에 따라 개발자가 클래스를 확장하고 사용하는 데 필요한 도구를 제공하는 것으로 보여진다. 이것이 바로 `Operation`과 같은 고차원의 추상화를 제공하는 이유이다.
###### State tracking 
- operation의 상태가 read-only이기 때문에, 먼저 read-write 방식으로 변경을 할 수 있는 방법을 만들어야 한다. 
- 그러므로 `State` 열거형을 class의 맨 윗부분에 생성한다.
~~~ swift 
class AsyncOperation: Operation { 
	enum State: String { 
		case ready, executing, finished 
		
		// KVO notifications을 위한 keyPath 설정 
		// 첫 번째 단어를 대문자해서 String 
		fileprivate var keyPath: String { 
			return "is\(rawValue.capitalized)"
		}
	}
}
~~~
- Operation 클래스는 KVO notification을 사용한다. 예를 들어, isExecuting 상태가 번경되면 KVO 알림이 전송된다. 그러나 위에서 설정한 상태 열거형은 'is' 접두사로 시작하지 않으며, Swift Style Guide에 따르면 열거형 항목은 소문자로 표시해야 한다. 
- Computed property `KeyPath`  는 앞서 언급한 KVO notification을 지원하는 데 도움이 된다. 현재 State 의 keyPath를 요청하면 상태 값의 첫 글자를 대문자로 변경하고 텍스트 is를 접두사로 사용한다. 따라서 실행 중인 경우 keyPath는 `isExecuting`을 반환하며, Operation 기본 클래스의 속성과 일치한다. 
- `keyPath`는 이 파일 전체에서 사용 가능해야 하지만 외부에서는 사용할 수 없어야 한다. private로 설정하면 열거형 자체 외부에서는 볼 수 없다. 
- 파일 전체 범위이므로, production code에서는 별도의 파일에 class를 배치해야 한다. 
- 이제 상태 유형을 생성했으므로, 상태를 보유할 변수가 필요하다. 값 변경 시 적절한 KVO notification을 보내야 하므로 property observers를 속성에 연결한다. 
~~~ swift 
	var state = State.ready { 
		// 값이 변경되면,
		willSet { 
			willChangeValue(forKey: newValue.keyPath)
			willChangeValue(forKey: state.keyPath)
		}
		// 값이 변경된 후
		didSet { 
			didChangeValue(forKey: oldValue.keyPath)
			didChangeValue(forKey: state.keyPath)
		}
	}
~~~
- 기본적으로 상태는 준비 상태이다. 상태 값을 변경할 때 실제로 4개의 KVO notification이 전송된다. 
- 만약 상태가 현재 준비상태이고 실행 중으로 업데이트하는 경우를 보자면, isReady는 false가 되고 isExecuting은 true가 된다. 다음과 같은 4개의 KVO notification이 전송된다. 
	- will change for `isReady`
	- will change for `isExecuting`
	- Did change for `isReady`
	- Did change for `isExecuting`
- Operation 기본 클래스는 isExecuting 및 isReady 속성이 변경되는 것을 알아야 한다. 
- 종료를 비동기로 하기 위해서는 값이 변경될 때 상태를 알려줘야 한다. 
###### Base properties 
- 이제 상태 변경을 추적하고 변경이 실제로 수행되었음을 알리는 방법을 갖추었으므로, 기본 클래스의 해당 메서드 인스턴스 대신 사용하여 상태를 사용하도록 오버라이드 해야 한다. 
~~~ swift 
override var isReady: Bool { 
	return super.isReady && state == .ready
}

override var isExecuting: Bool { 
	return state == .executing
}

override var isFinished: Bool { 
	return state == .finished 
}
~~~
- 스케줄러가 사용할 스레드를 찾을 준비가 되었는지 여부를 결정하는 동안 코드가 진행되는 모든 것을 인식하지 못하기 때문에 기본 클래스의 `isReady` 메서드를 확인하는 것이 중요하다. 
- 마지막으로 오바러이드 할 속성은 비동기 작업을 사용하고 있다는 것을 명시하는 것이다. 
~~~ swift 
override var isAsynchronous: Bool { 
	return true
}
~~~
###### Starting the operation 
- 이제 할 일은 `start` 메서드를 구현하는 것이다. 작업을 수동으로 실행하든 작업 대기열이 실행 하도록 하든 상관없이, 먼저 start 메서드가 호출되고 나서 main 메서드를 호출해야 한다. 
~~~ swift 
override func start() { 
	main()
	state = .executing
}
~~~
- `start` 메서드를 오버라이드할 때는 어떤 경우에도 super를 호출하지 말아야 한다. 
- 위 main() 과 state = .executing은 아마 거꾸로 보일 것이다. 하지만 그렇지 않다. 비동기 작업을 수행하므로 main 메서드는 거의 즉시 반환된다. 
- 따라서 수동으로 상태를 .executing으로 변경하여 작업이 진행 중 임을 알려야 한다. 
- 이렇게 작성된 class를 직접 사용하기 보다는 항상 AsyncOperation을 상속하는 클래스로 사용해야 한다. 
~~~ swift 
class AsyncSumOperation: AsyncOperation {
  let rhs: Int
  let lhs: Int
  var result: Int?
  
  init(lhs: Int, rhs: Int) {
    self.lhs = lhs
    self.rhs = rhs
    
    super.init()
  }
  
  override func main() {
    DispatchQueue.global().async {
      Thread.sleep(forTimeInterval: 2)
      self.result = self.lhs + self.rhs
      self.state = .finished
    }
  }
}

let queue = OperationQueue()
let pairs = [(2, 3), (5, 3), (1, 7), (12, 34), (99, 99)]

pairs.forEach { pair in
  let op = AsyncSumOperation(lhs: pair.0, rhs: pair.1)
  op.completionBlock = {
    guard let result = op.result else { return }
    print("\(pair.0) + \(pair.1) = \(result)")
  }
  
  queue.addOperation(op)
}

~~~
###### 비동기함수를 오퍼레이션으로 감싸는 이유는? 
- 이러한 AsyncOperation을 만들면서 까지 operation안 에다가 비동기 함수를 넣는 이유는 무엇일까
- 그것은 비동기 작업간의 순서 연결이 가능하기 때문이다. 즉, 순서 설정이 가능하기 때문이다. 
- 이러한 행위는 "pyramid of doom"을 피할 수 있다. 
~~~ swift 
loadData { (data) in
	loadImages (data, callback: { (images) in process Images (images, callback: { (result) in
		secondaryProcessing (result, callback: { (output) in
			DispatchQueue.main.async {
				print("This is your processed data:")
				for value in output {
					print (value)
					}
				}
			})
		})
	})
}
~~~
- 이러한 코드를 간결하고 직관적으로 변경할 수 있다. 
~~~ swift 
class LoadDataOperation: AsyncOperation { 
	var data: Data?
	
	override func main() { 
		loadData { loadedData in 
			self.data = loadedData
			self.state = .finished
		}
	}
}

class LoadImagesOperation: AsyncOperation { 
	var data: Data? 
	var image: [UIImage]? 
	
	override func main() { 
		guard let data = data else { return }
		loadImages(data) { loadedImage in 
			self.images = loadedImages
			self.state = .finished
		}
	}
}
~~~
- 이러한 Operation을 사용하여 원래의 콜백 기반 코드를 재구성할 수 있다.
~~~ swift 
let loadDataOperation = LoadDataOperation()
let loadImagesOperation = LoadImagesOperation() 
let processImagesOperation = ProcessImagesOperation() 
let secondaryProcessingOperation = SecondaryProcessingOperation()

loadImagesOperation.addDependency(loadDataOperation)
processImagesOpeartion.addDependency(loadImagesOperation)
secondaryProcessingOperation.addDependency(processImagesOperation)

let operations = [loadImagesOperation, processImagesOpeartion, secondaryProcessingOperation, secondaryProcessingOperation]

let queue  = OperationQueue() 

queue.addOperation(operations, waitUntilFinished: false)

queue.addOperation {
    DispatchQueue.main.async {
        print("This is your processed data:")
        for value in secondaryProcessingOperation.output {
            print(value)
        }
    }
}
~~~
#### Networked TiltShift 
- [[8. Operations]]과 [[9. Operation Queues]]에서 보면 하드코딩 된 이미지 목록을 사용했다. 이미지를 로딩을 비동기 작업인 네트워크를 활용해서 불러오는 코드를 작성해보겠다. 
##### NetworkImageOperation
##### Using NetworkImageFilter 

### 출처(참고문헌) 
- https://www.kodeco.com/books/concurrency-by-tutorials/v2.0/chapters/8-asynchronous-operations
- https://www.inflearn.com/course/lecture?courseSlug=iOS-Concurrency-GCD-Operation&unitId=34780&tab=curriculum
- https://developer.apple.com/documentation/foundation/operation/1416837-start

### 연결문서 
- [[8. Operations]]
- [[15. KVO(key Value Observing) (x)]]
- [[14. Pyramid of Doom (x)]]

### Tag
- #IOS/Concurrency/Operations/Asynchronous 