### 날짜: 2023-02-25 14:52

### 주제: RxSwift 스터디 과제) Chapter 12: Beginning RxCocoa
---
### 메모: 
> RxCocoa는 RxSwift Repo의 한 부분인 프레임워크이다. 
> RxCocoa는 모든 플랫폼에서 작동하며, Built-in extensions UI controls과 SDK classes를 custom wrapping한 extension set
#### Before RxCocoa
- Weather API 연결 예시 (APIController.swift)
~~~ swift 
   func currentWeather(city: String) -> Observable<Weather> {
     // Placeholder call
     return Observable.just(Weather(cityName: city,
                                    temperature: 20,
                                    humidity: 90,
                                    icon: iconNameToChar(icon: "01d")))
   }
~~~
- observable은 데이터를 수신하고 모든 가입자에게 일련의 데이터가 도착했음을 알린다. 또한 처리할 값을 푸시할 수 있다.
- 따라서 ViewController가 작업할 동안 observable을 구독할 적합한 장소는 viewDidLoad이다. 
- *구독이 늦어지면 이벤트 일부를 놓치거나, UI의 일부분이 데이터를 바인드하기 전에 보여질 수 있다.*
- *그러므로 앱에서 처리되고 사용자에게 표시되어야 하는 데이터를 만들거나 요청하기 전에 모든 구독을 만들어줘야 한다.*
- ViewController에서 viewDidLoad
~~~ swift
     ApiController.shared.currentWeather(city: "RxSwift")
         .observeOn(MainScheduler.instance)
         .subscribe(onNext: { data in
             self.tempLabel.text = "\(data.temperature)℃"
             self.iconLabel.text = data.icon
             self.humidityLabel.text = "\(data.humidity)%"
             self.cityNameLabel.text = data.cityName
         })
	    .disposed(by: disposeBag)
~~~
![[스크린샷 2023-02-28 00.00.48.png|250]]
- RxCocoa 프레임워크는 rx 키워드를 추가함으로서 UIKit을 사용할 수 있게 한다.
	- `text`는 `ControlPropert<String?>`라는, `ObservableType`이면서 동시에 `ObserverType`인 Observable을 리턴한다. 즉, 이를 통해 구독 및 새로운 이벤트 방출 모두 가능하다.
~~~ swift 
     // 1
     searchCityName.rx.text
         .filter { ($0 ?? "").characters.count > 0 }
         .flatMapLatest { text in
             return ApiController.shared.currentWeather(city: text ?? "Error")
                 .catchErrorJustReturn(ApiController.Weather.empty)
     }
         // 2
         .observeOn(MainScheduler.instance)
         .subscribe(onNext: {data in
             self.tempLabel.text = "\(data.temperature)℃"
             self.iconLabel.text = data.icon
             self.humidityLabel.text = "\(data.humidity)%"
             self.cityNameLabel.text = data.cityName
         })
         .disposed(by: bag)
~~~
#### What are binding observable
- 바인딩을 이해하기 쉬운 방법은 아래 두 개의 속성에 대한 관계를 생각해보는 것이다.
![[스크린샷 2023-02-28 00.08.22.png|300]]
- producer: 값을 만든다.
- Consumer: 만들어진 값을 수신하고 처리한다. 
	- **Consumer는 값을 반환할 수 없다.**
- 만약, 서로 상호 작용하는 binding을 만들려면 2개의 producer, 2개의 consumber를 만들어야 한다. 
-  바인딩을 할 수 있는 기본 함수는 `bind(to:)`다. observable을 다른 속성에 바인딩하기 위해서는 Receiver가 `ObservableType` 이어야한다.
- `bind(to:)` 함수는 `subscribe()`의 특별 맞춤 버전이다. `bind(to:)`는 호출되었을 때 부수작용이 없다.
~~~ swift 
 	// 1
     let search = searchCityName.rx.text
         .filter { ($0 ?? "").characters.count > 0 }
         .flatMapLatest { text in
             return ApiController.shared.currentWeather(city: text ?? "Error")
                 .catchErrorJustReturn(ApiController.Weather.empty)
         }
         .share(replay: 1)
         .observeOn(MainScheduler.instance)

     // 2    
     search.map { "\($0.temperature)℃" }
     	// 3
         .bind(to: tempLabel.rx.text)
         .disposed(by: bag)

     // 3
     search.map { "\($0.humidity)%" }
         .bind(to: humidityLabel.rx.text)
         .disposed(by: bag)

     search.map { $0.cityName }
         .bind(to: cityNameLabel.rx.text)
         .disposed(by: bag)

     search.map { $0.icon }
         .bind(to: iconLabel.rx.text)
         .disposed(by: bag)
~~~
https://jusung.github.io/shareReplay/ 
#### Traits
- UI 작업시 코드를 쉽고 직관적으로 작성해 사용할 수 있도록 도와주는 특별한 `Observable` 클래스의 모음
- 즉 Traits는 직관적이고 작성하기 쉬운 코드를 작성하는데 도움이 되는 `Observable`의 특수 클래스이다.
##### Traits의 규칙 
- 에러를 방출하지 않는다. 
- 메인 스케줄러에서 관찰한다. 
- 메인 스케줄러에서 구독된다. 
- `Signal`을 제외한 나머지 Trait은 자원을 공유한다.
##### RxCocoa의 Traits
###### ControlProperty951
###### ControlEvent
###### Driver

### 출처(참고문헌) 
- RxSwift. Reactive Programming with Swift 

### 연결문서 
- [[1. Custom Extensions]]
- [[1. Driver]]

### Tag
- #IOS/RxSwift/RxCocoa 