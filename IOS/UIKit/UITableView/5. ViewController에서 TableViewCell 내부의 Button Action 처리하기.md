https://co-dong.tistory.com/70

contentView.addSubview
addSubview



이러한 문제는 TableView의 Cell Reuse Mechanism과 관련이 있을 수 있습니다. TableView는 제한된 수의 Cell만 표시하기 때문에, 표시된 Cell이 화면 밖으로 나갈 때 재사용할 수 있습니다.

따라서, TableView는 스크롤링에 따라 Cell을 재사용하는데, 이때 기존 Cell의 상태를 저장하지 않고 재사용하기 때문에 버튼 클릭 이벤트의 처리에 문제가 발생할 수 있습니다.

버튼 클릭 이벤트를 처리하려면 적절한 액션 또는 델리게이트 메서드를 통해 Cell의 IndexPath를 가져와 작업을 수행해야 합니다. 그러나 TableView가 Cell을 재사용하면 IndexPath가 올바르지 않을 수 있으며, 이로 인해 버튼 클릭과 같은 작업이 정상적으로 수행되지 않을 수 있습니다.

해결 방법으로는 TableViewCell에서 버튼 클릭 이벤트를 처리하는 방식을 변경하는 것이 있습니다. 버튼 클릭 이벤트를 처리하는 델리게이트 패턴을 사용하여 TableView가 재사용하는 동안에도 올바른 IndexPath를 가져와 작업을 수행할 수 있습니다. 또는, 셀에 추가된 버튼을 TableView의 ContentView이 아닌, 별도의 뷰에 추가하여 해당 뷰에서 이벤트를 처리할 수 있도록 하는 방법도 있습니다.

UITableView에서 Cell의 contentView 내부에 버튼을 배치할 때, 버튼의 클릭 동작이 TableView의 스크롤링과 충돌하게 됩니다. 이는 TableView의 재사용 메커니즘으로 인해 발생하는 문제로, 뷰가 생성될 때 Cell의 높이가 아직 결정되지 않아서, TableView의 크기가 정해지지 않기 때문입니다.

이러한 문제를 해결하는 방법 중 하나는 버튼의 UIControlEventTouchUpInside 이벤트를 직접 처리하는 대신, TableView의 Delegate 메서드를 이용해 처리하는 것입니다.

예를 들어, 다음과 같이 tableView(_:didSelectRowAt:) 메서드를 사용하여 Cell 내부의 버튼이 아닌 다른 영역을 터치할 때 동작하는 코드를 작성할 수 있습니다.

```swift
func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
    // 버튼이 아닌 다른 부분을 터치하면 이 메서드가 호출됩니다.
    // 이 때 버튼의 클릭 동작을 처리할 수 있습니다.
    let cell = tableView.cellForRow(at: indexPath) as! CustomTableViewCell
    cell.handleButtonTap()
}
```

CustomTableViewCell에서는 handleButtonTap() 메서드를 정의하여 버튼 클릭 동작을 처리할 수 있습니다.

또 다른 방법은 Cell의 높이를 동적으로 결정하는 것입니다. 이를 위해서는 Cell의 높이를 계산하는 메서드인 tableView(_:heightForRowAt:)를 사용하면 됩니다.

```swift
func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
    let cell = tableView.dequeueReusableCell(withIdentifier: "CustomCell") as! CustomTableViewCell
    let data = dataSource[indexPath.row]
    cell.configure(with: data)
    return cell.contentView.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize).height
}
```

위의 코드에서는 CustomTableViewCell의 configure(with:) 메서드를 호출하여 Cell의 데이터를 설정하고, contentView.systemLayoutSizeFitting(_:) 메서드를 사용하여 Cell의 높이를 계산합니다.

SnapKit 라이브러리를 사용하면 다음과 같이 Cell 내부의 TextView와 같은 뷰의 높이를 동적으로 조정할 수 있습니다.

```swift
override func layoutSubviews() {
    super.layoutSubviews()
    textView.snp.updateConstraints { make in
        make.height.equalTo(textView.contentSize.height)
    }
}
```

위 코드에서는 TextView의 높이를 contentSize.height로 업데이트합니다. 이를 통해 TextView의 높이를 동적으로 조정할 수 있습니다. 이 방법은 Cell의 높이를 계산하는 메서드를 사용하지 않으므로, TableView가 더욱 빠르게 스크롤링될 수 있습니다.