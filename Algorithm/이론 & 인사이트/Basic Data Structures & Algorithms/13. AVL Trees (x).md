### 날짜: 2023-04-24 14:27

### 주제:  높이 균형을 유지하는 자가 균형 트리
---
### 메모: 
#### AVL Tree란? 
- 이진 탐색 트리의 평균 성능은 O(log n)을 나타낸다. 하지만, 균형이 잡히지 않은 트리는 성능을 저하시킬 수 있으며 최악의 경우 O(n)까지 떨어질 수 있다. 
- 1962년 Georgy Adelson-Velsky와 Evgenii Landis가 처음으로 자가 균형 이진 트리인 AVL 트리를 고안했다. 
- AVL트리는 값이 변경됨에 따라 자동으로 트리의 균형을 잡아줘서 O(log n)의 성능을 보장할 수 있게 해준다. 
##### Perfect balance 
- 이진 탐색 트리의 이상적인 형태로써, 완벽하게 균형 잡힌 상태이다. 
- **맨 위부터 아래까지 모든 수준의 트리가 노드로 채워진 상태를 의미한다.** 
##### 'Good-enough' balance
- Perfect balance을 만드는 것이 가장 이상적이지만, 실제로는 거의 불가능하다. 
- 예를 들어, 1, 3 또는 7개의 노드가 있는 트리는 완벽하게 균형 잡힐 수 있지만, 2, 4, 5 또는 6개의 노드가 있는 트리는 맨 아래 수준의 노드가 채워지지 않기 때문에 완벽하게 균형 잡힐 수 없습니다.
- **결국 균형 잡힌 트리는 맨 아래를 레벨을 제외하고 모든 수준의 트리가 채워져 있어야 한다는 것이다.**
##### Unbalanced 
- 이진 탐색 트리가 이 상태에 있다면 균형 상태가 아니게 되므로 성능 손실을 겪게 된다. 
- 결국, 이러한 상태가 발생하였을 때 균형 잡힌 상태로 맞춰줘야 한다.
#### 구현
- AVL 트리에서 이진 트리의 균형을 유지하기 위해서는 트리의 균형을 측정하는 방법이 필요하다. 
- **AVL 트리는 각 노드에 높이 속성을 사용하여 이를 달성할 수 있는데, 트리에서 노드의 높이란 현재 노드에서 가장 먼 리프 노드까지의 최장 거리를 의미한다.** 
- **각 노드의 자식 노드의 상대적인 높이를 사용하여 해당 노드가 균형 잡혀 있는지를 확인할 수 있다. 각 노드의 왼쪽 및 오른쪽 자식의 높이 차이는 최대 1이하여야 하며, 이 숫자를 균형 인수(balance factor)라고 한다.**
- balance factor가 2또는 -2 이상이면 균형 잡히지 않은 트리이다. 
- 그렇지만, rotation(회전) 활동을 해서 balance factor를 1또는 -1이하로 낮출 수 있다. 
~~~ swift 
public class AVLNode<Element> { 
	public var value: Element 
	public var leftChild: AVLNode? 
	public var rightChlid: AVLNode? 
	public var height = 0 
	
	public var balanceFactor: Int { 
		leftHeight - rightHeight 
	}
	
	public var leftHeight: Int { 
		leftChild?.height ?? -1
	}
	
	public var rightHeight: Int { 
		rightChild?.height ?? -1
	}
	
	public init(value: Element) { 
		self.value = value 
	}
}

extension AVLNode: CustomStringConvertible {
  
  public var description: String {
    diagram(for: self)
  }
  
  private func diagram(for node: AVLNode?,
                       _ top: String = "",
                       _ root: String = "",
                       _ bottom: String = "") -> String {
    guard let node = node else {
      return root + "nil\n"
    }
    if node.leftChild == nil && node.rightChild == nil {
      return root + "\(node.value)\n"
    }
    return diagram(for: node.rightChild, top + " ", top + "┌──", top + "│ ")
      + root + "\(node.value)\n"
      + diagram(for: node.leftChild, bottom + "│ ", bottom + "└──", bottom + " ")
  }
}
~~~
~~~ swift 
public struct AVLTree<Element: Comparable> { 
	public private(set) var root: AVLNode<Element>? 
	
	public init() { }
}

extension AVLTree: CustomStringConvertible { 
	public var description: String { 
		guard let root = root else { return "Empty Tree"}
		return String(describing : root)
	}
}
~~~
- **RR 회전(Left Rotation)**: 삽입 또는 삭제로 인해 노드의 오른쪽 서브트리에 불균형이 발생한 경우 사용된다.
~~~ swift 
extension AVLTree { 
	private func leftRotate(_ node: AVLNode<Element>) -> AVLNode<Element> { 
		let pivot = node.rightChild!
		
		node.rightChild = pivot.leftChild
		
		pivot.leftChild = node
		
		node.height = max(node.leftHeight, node.rightHeight) + 1 
		pivot.height = max(pivot.leftHeight, pivot.rightHeight) + 1 
		
		return pivot
	}
}
~~~
- **LL 회전(Right Rotation)**: 삽입 또는 삭제로 인해 노드의 왼쪽 서브트리에 불균형이 발생한 경우 사용된다.
~~~ swift 

~~~
- **LR 회전(Left-Right Rotation)**: 삽입 또는 삭제로 인해 노드의 왼쪽 서브트리의 오른쪽 서브트리에 불균형이 발생한 경우 사용된다. 이 회전은 왼쪽 서브트리에 대한 왼쪽 회전 후, 전체 트리에 대한 오른쪽 회전을 수행한다.
- **RL 회전(Right-Left Rotation)**: 삽입 또는 삭제로 인해 노드의 오른쪽 서브트리의 왼쪽 서브트리에 불균형이 발생한 경우 사용된다. 이 회전은 오른쪽 서브트리에 대한 오른쪽 회전 후, 전체 트리에 대한 왼쪽 회전을 수행한다.
### 출처(참고문헌) 
- https://www.kodeco.com/books/data-structures-algorithms-in-swift/v4.0/chapters/16-avl-trees

### 연결문서 
- [[11. Binary Trees]]
- [[12. Binary Search Trees]]
- [[14. Binary Search Tree vs. AVL Tree]]

### Tag
- #DataStructure/Tree/BinaryTree/AVLTree 