### 날짜: 2023-04-03 16:41

### 주제:  DP로 해결하는 문제
---
### 메모: 
#### 문제 
- 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
1.  X가 3으로 나누어 떨어지면, 3으로 나눈다.
2.  X가 2로 나누어 떨어지면, 2로 나눈다.
3.  1을 뺀다.
- 정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
##### 입력
- 첫째 줄에 1보다 크거나 같고, $10^{6}$보다 작거나 같은 정수 N이 주어진다.
##### 출력 
- 첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.
#### 해설 
- X가 1-3일 때 최솟값은 1이다. 
- X가 4일 때 최솟값은 2이다.  ( 2로 나누고 1로 뺀다.)
- X가 5일 때 최솟값은 3이다.  ( 1로 빼고 2로 나누고 1로 뺀다. )
- X가 6일 때 최솟값은 2이다.  ( 3으로 나누고 2로 나눈다. )
- X가 7일 때 최솟값은 3이다. ( 1로 빼고 3으로 나누고 2로 나눈다. )
- X가 8일 때 최솟값은 3이다. 
- X가 9일 때 최솟값은 3이다.
- 위 식을 보면 값이 커지면 커질수록 그 전의 값들을 참고하는 것을 확인할 수 있다. 그것을 고려하면,
- (X-1)의 값의 1을 더한 값과 X를 2또는 3으로 나눌 때 값의 1을 더한 값과 최솟값을 비교해서 제일 작은 값을 X값으로 더해준다. 
- 그 전의 값을 비교하면서 채워나가면 되니, Tabulation 기법을 활용한다. 
#### 코드
~~~ swift 
import Foundation 

let n = Int(readLine()!)! 

var dp = [Int](repeating: 0, count: n + 1)

for i in 2..<n+1 {
	dp[i] = dp[i-1] + 1 
	if i % 3 == 0 { 
		dp[i] = min(dp[i], dp[i / 3] + 1)
	}
	if i % 2 == 0 { 
		dp[i] = min(dp[i], dp[i / 2] +  1)
	}
}

print(dp[n])
~~~

### 출처(참고문헌) 
- https://www.acmicpc.net/problem/1463

### 연결문서 
- [[8.  DP(Dynamic Programming)]]
- [[9. Tabulation vs Memoization]]

### Tag
- #Algorithm/Dynamic_Programming 
- #Algorithm/BaekJoon/Silver3