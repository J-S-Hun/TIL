### 날짜: 2023-04-09 00:25

### 주제: DP문제 풀이 전략
---
### 메모: 
#### 1로 만들기
##### 내용 
- 정수 X가 주어질 때 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지이다. 
	- X가 5로 나누어떨어지면, 5로 나눈다. 
	- X가 3으로 나누어떨어지면, 3으로 나눈다.
	- X가 2로 나누어떨어지면, 2로 나눈다. 
	- X에서 1을 뺀다. 
- 정수 X가 주어졌을 때, 연산 4개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오. 
- 예를 들어 정수가 26이면 다음과 같이 계산해서 3번의 연산이 최솟값이다.
1. 26 - 1 = 25
2. 25 / 5 = 5 
3. 5 / 5 = 1
- 입력 조건: 첫째 줄에 정수 X가 주어진다 (1<= X <= 30,000)
- 출력 조건: 첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다. 
- 26 -> 3
##### 해설
- 이 문제는 유명한 DP 문제 유형 중 하나이다. 피보나치 수열 문제를 도식화했던 것처럼 문제를 풀기 전에 함수가 호출되는 과정을 그림으로 그려보면 이해하는 데 도움이 된다. 
- 예를 들어 n = 6 일 때, 함수가 호출되는 과정을 그리면 
	-               f(6)
	-  ⬇️          ⬇️          ⬇️
	- f(5)        f(3)       f(2)
	- ⬇️⬇️      ⬇️⬇️      ⬇️⬇️
	- f(4)f(1) f(2)f(1) f(1)f(1)
	- ..................................... 
$$a_{i} = min(a_{i-1},a_{i/2},a_{i/3},a_{i/5}) + 1$$
- 점화식 끝에 1을 더해주는 이유는 함수의 호출 횟수를 구해야 하기 때문이다. 
##### 코드
~~~ swift 
import Foundation 

let n = Int(readLine()!)!
var dp = [Int](repeating: 0, count: n + 1)

for i in 2..< n + 1 { 
	// 전 값의 경우의수 + 1 -> 구하고자 하는 수의 1을 먼저 뺀 값을 dp[i]에 넣기
	dp[i] = dp[i - 1] + 1
	// 3으로 나눌때 나머지가 0이면
	if i % 3 == 0 { 
		dp[i] = min(dp[i], dp[i / 3] + 1)
	}
	// 2으로 나눌때 나머지가 0이면
	if i % 2 == 0 { 
		dp[i] = min(dp[i], dp[i / 2] + 1)
	}
	// 5으로 나눌때 나머지가 0이면
	if i % 5 == 0 { 
		dp[i] = min(dp[i], dp[i / 5] + 1)
	}
}
~~~
- 처음 경우의 수를 계산해서 배열에 넣고 그 다음 경우의 수를 전의 경우의 수를 참고해서 계산
#### 개미 전사 
##### 내용 
- 개미 전사는 부족한 식량을 충당하고자 메뚜기 마을의 식략창고를 몰래 공격하려고 한다. 메뚜기 마을에는 여러 개의 식량창고가 있는데 식량창고는 일직선으로 이어져 있다. 각 식량창고에는 정해진 수의 식량을 저장하고 있으며 개미 전사는 식량창고를 선택적으로 약탈하여 식량을 빼앗을 예정이다. 
- 이때 메뚜기 정찰병들은 일직선상에 존재하는 식량창고 중에서 서로 인접한 식량창고가 공격받으면 바로 알아챌 수 있다. 따라서 개미 전사가 정찰병에게 들키지 않고 식량창고를 약탈하기 위해서는 최소한 한 칸 이상 떨어진 식량창고를 약탈해야 한다. 예를 들어 식량착고 4개가 다음과 같이 존재한다고 가정하자.
- {1, 3, 1, 5} 
- 이때 개미 전사는 두 번째 식량창고와 네 번째 식량창고를 선택했을 때 최댓값인 총 8개의 식량을 빼앗을 수 있다. 개미 전사는 식량창고가 이렇게 일직선상일 때 최대한 많은 식량을 얻기를 원한다. 
- 개미 전사를 위해 식량창고 N개에 대한 정보가 주어졌을 때 얻을 수 있는 식량의 최댓값을 구하는 프로그램을 작성하시오.
- 첫째 줄에 식량창고의 개수 N이 주어진다. (3 <= N <= 100)
- 둘째 줄에 공백으로 구분되어 각 식량창고에 저장된 식량의 개수 K가 주어진다. (0 <= K <= 1000)
- 첫째 줄에 개미 전사가 얻을 수 있는 식량의 최댓값을 출력하시오.
##### 해설
- 내가 생각했을 때 DP 문제의 핵심은 머리속이든, 손으로 그리든 그림으로 도식화해서 점화식을 만드는 것이다.
- 이 문제를 도식화하면 N 이 4일 때 총 8가지의 경우의 수가 나오며, 그 중 최대값의 경우의 수를 고르면 된다.
- 하지만 이 문제는 모든 경우의 수를 확인하는 것 보다 점화식의 아이디어를 활용하면 쉽게 풀 수 있다. 
	- 만약 i - 1 번째 식량창고를 털기로 결정했다면 i 번째 식량창고는 털 수 없다. 
	- 만약 i - 2 번째 식량창고를 털기로 결정했다면 i 번째 식량창고를 털 수 있다, 
	- 즉 두 상황 중 더 많은 식량을 털 수 있는 경우를 선택하면 된다. 그렇게 될 경우 i - 3, i - 4 번 째는 고려할 필요가 없다. 
- 따라서 i번째 식량창고에 있는 시걍의 양이 $k_{i}$ 라고 했을 때 점화식은 다음과 같다. 
$$a_{i} = max(a_{i-1},a_{i-2} + k_{i})$$
##### 코드
~~~ swift 
import Foundation 

let n = Int(readLine()!)!

let array = readLine()!.components(separatedBy: " ").map {Int($0)!}

var dp = [Int]() 

dp.append(array[0])
// 배열이 2개 일 때 첫번째와 두번째 비교
dp.append(max(array[0], array[1]))

for i in 2..<n { 
	dp.append(max(dp[i - 1], dp[i - 2] + array[i]))
}

print(dp[n-1])
~~~
#### 바닥 공사
##### 내용 
- 가로의 길이가 N, 세로의 길이가 2인 직사각형 형태의 얇은 바닥이 있다. 태일이는 이 얇은 바닥을 1 x 2의 덮개, 2 x 1의 덮개, 2 x 2의 덮개를 이용해 채우고자 한다.
- 이때 바닥을 채우는 모든 경우의 수를 구하는 프로그램을 작성하시오. 예를 들어 2 x 3 크기의 바닥을 채우는 경우의 수는 5가지 이다. 
- 입력 조건: 첫째 줄에 N이 주어진다. 
- 출력 조건: 첫째 줄에 2 x N 크기의 바닥을 채우는 방법의 수는 7956,796으로 나눈 나머지를 출력한다. 
	- 결과값이 엄청나게 커지는 것을 방지하기 위해.
##### 해설
- 이 문제는 다이나맥 프로그래밍의 기초 예제에서 빠질 수 없는 타일링 문제 유형이다.
- 이 문제 또한 그림으로 그려서 생각하면 어렵지 않게 풀 수 있다. 
- 왼쪽부터 i - 1 까지 길이가 덮개로 이미 채워져 있으면 2 x 1의 덮개를 채우는 하나의 경우밖에 존재하지 않는다. 
- 왼쪽부터 i - 2 까지 길이가 덮개로 이미 채워져 있으면 1 x 2 덮개 2개를 넣는 경우, 혹은 2 x 2의 덮개 하나를 넣는 경우로 2가지 경우가 존재한다. 
	- 참고로 2 x 1 덮개 2개를 넣는 경우를 고려하지 않는 이유는 i x 1에서 이미 해당 경우가 고려되었기 때문이다. 
- 또한 이 문제 역시 i 번째 위치에 대한 최적의 해를 구할 때 왼쪽부터 (i-3)번째 이하의 위치에 대한 최적의 해에 대해서는 고려할 필요가 없다. 
- 왜냐하면 사용할 수 있는 덮개의 형태가 최대 2 x 2크기의 직사각형 형태이기 때문이다. 
- 이를 점화식으로 나타내면 
$$a_{i} = a_{i-1} + a_{i-2}*2$$
##### 코드
~~~ swift 
let n = Int(readLine()!)!

var dp = [Int](repeating: 0, count: n)

dp[0] =  1

dp[1] = 3 

for i in 2..<n { 
	dp[i] = (dp[i-1]+ (2* dp[i-2])) % 796796
}

print(dp[n-1])
~~~
#### ⭐️ 효율적인 화폐 구성 
##### 내용
- N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다. 이때 각 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다. 
- 예를 들어 2원 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수이다. 
- 입력 조건: 첫째 줄에 N,M이 주어진다. (1 <= n <= 100, 1 <= m <= 10000)
- 입력 조건: 이후 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐 가치는 10,000보다 작거나 같은 자연수이다. 
- 출력 조건: 첫째 줄에 M원을 만들기 위한 최소환의 화폐 개수를 출력한다. 
- 출력 조건: 불가능할 때는 -1을 출력한다.
##### 해설 
- 이 문제는 그리디에서 다루었던 거스름돈 문제와 거의 동일하다. 단지 화폐 단위에서 큰 단위가 작은 단위의 배수가 아니라는 점만 다르다. 그렇기 때문에 그리디 알고리즘을 사용했던 예시처럼 매번 가장 큰 화폐 단위부터 처리하는 방법으로는 해결할 수 없고 다이나믹 프로그래밍을 이용해야 한다. 
- 이번 문제는 적은 금액부터 큰 금액까지 확인하며 차례대로 만들 수 있는 최소한의 화폐 개수를 찾으면 된다. 금액 i를 만들 수 있는 최소한의 화폐 계수를 $a_{i}$, 화폐의 단위를 k라고 했을 때 다음과 같이 점화식을 작성할 수 있다. 
	- $a_{i-k}$ 를 만드는 방법이 존재하는 경우, $a_{i} = min(a_{i},a_{i-k}+1)$
	- $a_{i-k}$ 를 만드는 방법이 존재하지 않는 경우. $a_{i} = 10,001$
	- m의 최대값이 10,000이니 그 이상의 값인 10,001을 넣어 준다.
- 이 점화식을 모든 화폐 단위에 대하여 차례대로 적용하면 된다. 실제로 문제를 풀기 위해서는 가장 먼저 K의 크기만큼 리스트를 할당한다. 이후에 각 인덱스를 '금액'으로 고려하여 Memoization 또는 Tabulation을 진행한다. 
- 예를 들어 N = 3, K = 7이고, 각 화폐의 단위가 2, 3, 5인 경우를 생각하면 
1. k크기의 배열을 최댓값으로 초기화 후
2. 숫자의 크기는 상관없이 첫 번째 숫자의 배열 만큼 채워 넣는다. 즉 
	[0,1,2,3,4,5,6,7] 배열에서 화폐단위가 2일 시 [0,max,1,max,2,max,3,max] 가 된다. 
3. 다음 숫자 배열 만큼 채워 넣는다. 
4. 마지막 숫자 까지 배열에 채워 넣고 배열의 마지막 값을 방출한다. 
	-  0번째는 만들 수 있는 개수가 0인 것을 활용하여 문제를 해결하면 된다. 즉, 2 index에서  2의 배수 만큼 뒤로 간 값과 비교해서 더 작은 값을 4 index의 넣어 주는 형식으로 해결하면 된다. 
##### 코드
~~~ swift 
import Foundation 
let NMarray = readLine()!.components(separatedBy: " ").map { Int($0)! } 
let N = NMarray[0] 
let M = NMarray[1]  

var array = [Int]()  
for _ in 0..<N {
	array.append(Int(readLine()!)!)
 }  
 
 let INF = Int.max 
 var dp = [Int](repeating: INF, count: M+1)
// 0 일 때는 갯수가 0 
dp[0] = 0 
// dp 개수가 m+1 인경우는 0번째 1번째 ~ M번째 까지 다 계산하기 때문 
for i in 0..<N {     
	if array[i] <= M {         
		for j in array[i]...M { 
            if dp[j - array[i]] != INF { 
	                dp[j] = min(dp[j], dp[j - array[i]] + 1) 
		          }       
	        }  
	      } 
	  } 
 print(dp) if dp[M] == INF {     print(-1) } else {     print(dp[M]) }
~~~

### 출처(참고문헌) 
- 이코테. 다이나믹 프로그래밍 2. 1로 만들기
- 이코테. 다이나믹 프로그래밍 3. 개미 전사 
- 이코테. 다이나믹 프로그래밍 4. 바닥 공사
- 이코테. 다이나믹 프로그래밍 5. 효율적인 화폐 구성

### 연결문서 
- [[8.  DP(Dynamic Programming)]]
- [[9. Tabulation vs Memoization]]

### Tag
- #Algorithm/Dynamic_Programming 